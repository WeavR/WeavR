<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AliasNotFound" xml:space="preserve">
    <value>Alias '{0}' not found.</value>
  </data>
  <data name="AmbiguousCall" xml:space="preserve">
    <value>The call is ambiguous between the following methods or properties: '{0}' and '{1}'.</value>
  </data>
  <data name="AssignmentLeftHandValueExpected" xml:space="preserve">
    <value>The left-hand side of an assignment must be a variable, property or indexer.</value>
  </data>
  <data name="BadArgumentTypes" xml:space="preserve">
    <value>The best overloaded method match for '{0}' has some invalid arguments.</value>
  </data>
  <data name="BadArgumentType" xml:space="preserve">
    <value>Argument '{0}': cannot convert from '{1}' to '{2}'.</value>
  </data>
  <data name="BadBinaryOperation" xml:space="preserve">
    <value>Operator '{0}' cannot be applied to operands of type '{1}' and '{2}'.</value>
  </data>
  <data name="BadExternAlias" xml:space="preserve">
    <value>The extern alias '{0}' was not specified in a /reference option.</value>
  </data>
  <data name="BadNumberOfArguments" xml:space="preserve">
    <value>No overload for method '{0}' takes '{1}' arguments.</value>
  </data>
  <data name="BadReferenceCompareLeft" xml:space="preserve">
    <value>Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'.</value>
  </data>
  <data name="BadReferenceCompareRight" xml:space="preserve">
    <value>Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'.</value>
  </data>
  <data name="BadReturnType" xml:space="preserve">
    <value>'{0}' has the wrong return type.</value>
  </data>
  <data name="BadUnaryOperation" xml:space="preserve">
    <value>Operator '{0}' cannot be applied to operand of type '{1}'.</value>
  </data>
  <data name="BadUseOfSymbol" xml:space="preserve">
    <value>'{0}' is a '{1}' but is used like a '{2}'.</value>
  </data>
  <data name="BatchFileNotRead" xml:space="preserve">
    <value>Could not read option batch file '{0}'. {1}.</value>
  </data>
  <data name="DuplicateResponseFile" xml:space="preserve">
    <value>Response file '{0}' included multiple times.</value>
  </data>
  <data name="InaccessibleTypeMember" xml:space="preserve">
    <value>'{0}' is inaccessible due to its protection level.</value>
  </data>
  <data name="InvalidCodePage" xml:space="preserve">
    <value>Code page '{0}' is invalid or not installed.</value>
  </data>
  <data name="InvalidCompilerOption" xml:space="preserve">
    <value>Invalid option: '{0}'.</value>
  </data>
  <data name="IsBinaryFile" xml:space="preserve">
    <value>'{0}' is a binary file instead of a source code file.</value>
  </data>
  <data name="NoExplicitConversion" xml:space="preserve">
    <value>Cannot convert type '{0}' to '{1}'.</value>
  </data>
  <data name="CantInferMethTypeArgs" xml:space="preserve">
    <value>The type arguments for method '{0}' cannot be inferred from the usage. Try specifying the type arguments explicitly.</value>
  </data>
  <data name="ConstOutOfRange" xml:space="preserve">
    <value>Constant value '{0}' cannot be converted to a '{1}'.</value>
  </data>
  <data name="ConstOutOfRangeChecked" xml:space="preserve">
    <value>Constant value '{0}' cannot be converted to a '{1}' (use 'unchecked' syntax to override).</value>
  </data>
  <data name="ExpressionHasSideEffect" xml:space="preserve">
    <value>Evaluating this expression has the side effect of modifying memory, which is not permitted in this context.</value>
  </data>
  <data name="LabelNotFound" xml:space="preserve">
    <value>Label '{0}' can not be found within the scope of the goto statement.</value>
  </data>
  <data name="NameNotInContext" xml:space="preserve">
    <value>The name '{0}' does not exist in the current context.</value>
  </data>
  <data name="NoImplicitConvCast" xml:space="preserve">
    <value>Cannot implicitly convert type '{0}' to '{1}'. An explicit conversion exists (are you missing a cast?)</value>
  </data>
  <data name="NoImplicitConversion" xml:space="preserve">
    <value>Cannot implicitly convert type '{0}' to '{1}'.</value>
  </data>
  <data name="NoMatchingOverload" xml:space="preserve">
    <value>No overload for '{1}' matches delegate '{0}'.</value>
  </data>
  <data name="NoSourceFiles" xml:space="preserve">
    <value>No source files to compile.</value>
  </data>
  <data name="NoSuchFile" xml:space="preserve">
    <value>File '{0}' does not exist.</value>
  </data>
  <data name="NoSuchMember" xml:space="preserve">
    <value>'{0}' does not contain a definition for '{1}'.</value>
  </data>
  <data name="ObjectProhibited" xml:space="preserve">
    <value>Static member '{0}' cannot be accessed with an instance reference; qualify it with a type name instead.</value>
  </data>
  <data name="ObjectRequired" xml:space="preserve">
    <value>An object reference is required for the nonstatic field, method, or property '{0}'.</value>
  </data>
  <data name="PointerExpected" xml:space="preserve">
    <value>The left of '{0}' must point to a struct or union.</value>
  </data>
  <data name="SingleTypeNameNotFound" xml:space="preserve">
    <value>The type or namespace name '{0}' could not be found (are you missing a using directive or an assembly reference?)</value>
  </data>
  <data name="SourceFileNotRead" xml:space="preserve">
    <value>Source file '{0}' could not be read. {1}.</value>
  </data>
  <data name="SourceFileTooLarge" xml:space="preserve">
    <value>Source file '{0}' is too large to be compiled.</value>
  </data>
  <data name="PotentialUnintendRangeComparison" xml:space="preserve">
    <value>'{0}' probably does not express what you intended; use two conjoined conditions to express an interval or parenthesize the {1} comparison.</value>
  </data>
  <data name="CannotCallNonMethod" xml:space="preserve">
    <value>'{0}' is not a method and cannot be called.</value>
  </data>
  <data name="ExpressionStatementHasNoSideEffect" xml:space="preserve">
    <value>The expression '{0}' has no side effect; expected operation with side effect.</value>
  </data>
  <data name="ConstInReadsOrWritesClause" xml:space="preserve">
    <value>Use of constant value '{0}' in reads/writes clause is meaningless; this is probably not what you wanted.</value>
  </data>
  <data name="NoImplicitConversionForValue" xml:space="preserve">
    <value>Cannot implicitly convert value '{0}' to type '{1}'.</value>
  </data>
  <data name="CannotTakeAddress" xml:space="preserve">
    <value>Cannot take the address of the given expression.</value>
  </data>
  <data name="CannotInferTypeOfConditional" xml:space="preserve">
    <value>Type of conditional expression cannot be determined.</value>
  </data>
  <data name="CannotInferTypeOfConditionalDueToAmbiguity" xml:space="preserve">
    <value>Type of conditional expression cannot be determined because there are implicit conversions between '{0}' and '{1}'; try adding an explicit cast to one of the arguments.</value>
  </data>
  <data name="OutParameterReferenceNotAllowedHere" xml:space="preserve">
    <value>Reference to out parameter '{0}' not allowed in this context.</value>
  </data>
  <data name="UndefinedOperationOnVoidPointers" xml:space="preserve">
    <value>The operation in question is undefined on void pointers.</value>
  </data>
  <data name="InvalidFileOrPath" xml:space="preserve">
    <value>Error while accessing file or path '{0}' -  {1}</value>
    <comment>The trailing '.' comes from the exception's message</comment>
  </data>
  <data name="WrongNumberOfArgumentsInConstructorCall" xml:space="preserve">
    <value>'{0}' does not contain a constructor that takes {1} arguments.</value>
  </data>
  <data name="ExtensionMethodsOnlyInNonGenericClass" xml:space="preserve">
    <value>Extension methods must be defined in a non-generic static class.</value>
  </data>
  <data name="ExtensionMethodsOnlyInStaticClass" xml:space="preserve">
    <value>Extension methods must be defined in a top-level static class.</value>
  </data>
  <data name="ExplicitSizeDoesNotMatchInitializer" xml:space="preserve">
    <value>Explicit array size {0} does not match array initializer dimension {1}.</value>
  </data>
  <data name="InitializerCountInconsistent" xml:space="preserve">
    <value>This initializer element count {1} is different from count {0} in first element.</value>
  </data>
  <data name="MustBeConstInt" xml:space="preserve">
    <value>Array sizes must be int32 constants if an initializer is supplied.</value>
  </data>
  <data name="IllegalUseOfType" xml:space="preserve">
    <value>'{0}' : illegal use of type '{1}'.</value>
  </data>
  <data name="TypeNameNotFound" xml:space="preserve">
    <value>The type or namespace name '{1}' does not exist in the namespace '{0}' (are you missing an assembly reference?)</value>
  </data>
</root>